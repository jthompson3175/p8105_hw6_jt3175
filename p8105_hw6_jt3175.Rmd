---
title: "Homework 6"
author: "Julia Thompson"
date: "11/20/2019"
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(modelr)
library(mgcv)

knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
	fig.width = 8, 
  fig.height = 6,
  out.width = "90%"
)
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)
scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
theme_set(theme_minimal() + theme(legend.position = "bottom"))
```


## Problem 1

Load and clean the data for regression analysis (i.e. convert numeric to factor where appropriate, check for missing data, etc.).

We load and clean the data for regression analysis, and find that there are no missing values in any of the columns. We also recode and convert _babysex_, _frace_, _malform_, and _mrace_ to factor variables. 

```{r}
birthweight = read_csv("./data/birthweight.csv") 

# check for missing data

ismissing = map(.x = birthweight, ~ sum(is.na(.x))) %>%  # why do you need the ~ ?!?
  bind_cols()

# male = 1, female = 2
# 1 = White, 2 = Black, 3 = Asian, 4 = Puerto Rican, 8 = Other, 9 = Unknown
# 0 = absent, 1 = present
# 1 = White, 2 = Black, 3 = Asian, 4 = Puerto Rican, 8 = Other

# Recode variables to make sense

birthweight = birthweight %>% 
  mutate(
    babysex = recode(babysex, `1` = "male", `2` = "female"),
    frace = recode(frace, `1` = "white", `2` = "black", `3` = "asian", `4` = "puerto rican", `8` = "other", `9` = "unknown"),
    malform = recode(malform, `0` = "absent", `1` = "present"),
    mrace = recode(mrace,  `1` = "white", `2` = "black", `3` = "asian", `4` = "puerto rican", `8` = "other")
  )

# change the above recoded variables into factors with levels corresponding to the above order

birthweight = birthweight %>% 
  mutate(
    babysex = factor(babysex, levels = c("male", "female")),
    frace = factor(frace, levels = c("white", "black", "asian", "puerto rican", "other", "unknown")),
    malform = factor(malform, levels = c("absent", "present")),
    mrace = factor(mrace, levels = c("white", "black", "asian", "puerto rican", "other"))
  )
```

Propose a regression model for birthweight. This model may be based on a hypothesized structure for the factors that underly birthweight, on a data-driven model-building process, or a combination of the two. Describe your modeling process and show a plot of model residuals against fitted values – use add_predictions and add_residuals in making this plot.

We used a hypothesized structure consulting literature for the factors that underly birthweight to reduce our number of potential predictors. We will continue with the following: gender (_babysex_), mother's BMI (_ppbmi_), mother's height (_mheigth_), cigarettes smoked per day (_smoken_), and mother's age (_momage_). We chose a final model by fitting an interaction term between mother's age and number of cigarettes smoked per day, as indicated by past research. Because the interaction term is significant and there is evidence in the literature of interaction between age and smoking, we will keep the interaction in our final model. We then create a plot of residuals vs fitted values and find that our points are centered around 0 with no clear patterns that would be problematic. 

```{r}
# interaction between smoking status and age - this interaction term is significant, so we will keep this as our final model

interaction_model = lm(bwt ~ babysex + ppbmi + mheight + momage*smoken, data = birthweight) 
summary(interaction_model)

# show a plot of residuals vs fitted

birthweight = 
  birthweight %>% 
  add_residuals(interaction_model) %>% 
  add_predictions(interaction_model)

# residuals are clustered, but there is no clear pattern... seems ok enough to proceed

ggplot(birthweight, aes(x = pred, y = resid))+
  geom_point()
```

Compare your model to two others:

One using length at birth and gestational age as predictors (main effects only)
One using head circumference, length, sex, and all interactions (including the three-way interaction) between these

```{r}
# This is just for me to think about it 

simple_model_given = lm(bwt ~ blength + gaweeks, data = birthweight)
summary(simple_model_given)
  
complex_model_given = lm(bwt ~ babysex * bhead * blength, data = birthweight)
summary(complex_model_given)
```

Make this comparison in terms of the cross-validated prediction error; use crossv_mc and functions in purrr as appropriate.

```{r}
# need to create testing and training datasets to use on all 3 models.

# models to compare:
# interaction_model
# simple_model_given
# complex_model_given

cv_df = crossv_mc(birthweight, 10)

cv_df = cv_df %>% 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble)
  )

```

```{r}
# Now fit the respective models to each

cv_df = 
  cv_df %>% 
  mutate(interaction_model = map(train, ~lm(bwt ~ babysex + ppbmi + mheight + momage * smoken, data = .x)),
         simple_model_given = map(train, ~lm(bwt ~ blength + gaweeks, data = .x)),
         complex_model_given = map(train, ~lm(bwt ~ babysex * bhead * blength, data = .x))) %>% 
  mutate(rmse_interaction = map2_dbl(interaction_model, test, ~rmse(model = .x, data = .y)),
         rmse_simple = map2_dbl(simple_model_given, test, ~rmse(model = .x, data = .y)),
         rmse_complex = map2_dbl(complex_model_given, test, ~rmse(model = .x, data = .y)))

cv_df %>% 
  select(starts_with("rmse")) %>% 
pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin()
```

http://web.b.ebscohost.com/ehost/pdfviewer/pdfviewer?vid=1&sid=d6056f5b-5ea8-4211-8071-e675375944e1%40pdc-v-sessmgr04


## Problem 2

```{r}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2017-01-01",
    date_max = "2017-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())
```

We’ll focus on a simple linear regression with tmax as the response and tmin as the predictor.

Use 5000 bootstrap samples and, for each bootstrap sample, produce estimates of these two quantities.

```{r}
boot_straps = 
  weather_df %>% 
  modelr::bootstrap(n = 100)
```

```{r}
bootstrap = 
  weather_df %>% 
  modelr::bootstrap(n = 100) %>% 
  mutate(
    models = map(strap, ~lm(tmax ~ tmin, data = .x))
  )

output = 
  bootstrap %>% 
  mutate(
    results_ln = map(models, broom::tidy),
    results_rsq = map(models, broom::glance)
    ) %>% 
  select(-strap, -models) %>% 
  unnest(results_ln, results_rsq) %>% 
  select(.id, term, estimate, adj.r.squared) %>% 
  pivot_wider(
    names_from = term, 
    values_from = estimate
  ) %>% 
  janitor::clean_names() %>% 
  mutate(
    ln_est = log(intercept * tmin)
  ) %>% 
  select(adj_r_squared, ln_est)
```

Plot the distribution of your estimates, and describe these in words.

```{r}

```

Using the 5000 bootstrap estimates, identify the 2.5% and 97.5% quantiles to provide a 95% confidence interval

```{r}

```


